@startuml business7_regular_sync
Title Regular Sync 业务主线: 从 Initial 切换 -> 订阅 Gossip -> 实时处理新区块 -> 处理缺失父块 -> 保持与网络同步

start

partition "从 Initial 切换到 Regular Sync" {
  :Initial Sync / Checkpoint Sync 完成后;
  :checkTransitionToRegularSync()\n- currentSlot := chain.CurrentSlot()\n- headSlot := chain.HeadSlot()\n- 若 currentSlot - headSlot < SlotsPerEpoch 则:\n- setInitialSyncComplete()\n- log.Info("Transitioned to regular sync");
}

partition "订阅 Gossipsub 主题" {
  :RegularSync.registerSubscribers()\n- subscribeToBlocks() 订阅 beacon_block 主题\n- subscribeToAggregateAndProof() 等其他主题\n- manageAttestationSubnets() 动态 attestation 子网;

  :subscribeToBlocks()\n- topic := P2P.BlockTopic()\n- blockSub := P2P.PubSub().Subscribe(topic)\n- 启动 beaconBlockSubscriber(ctx, blockSub) 循环读取消息;
}

partition "接收新区块并快速路径处理" {
  :beaconBlockSubscriber(ctx, sub)\n- 循环调用 sub.Next(ctx) 取 Gossip 消息\n- 将原始消息 decode 为 SignedBeaconBlock;

  :对每个 signed 调用 hasParent(signed);
  if (hasParent == true) then (有父块)
    :快速路径: 直接调用 chain.ReceiveBlock(ctx, signed, blockRoot);
    :ReceiveBlock 内部执行 Block Processing Pipeline
      (参见 Block Processing 章节: 基本验证/签名/状态转换/forkchoice 更新);
  else (父块缺失)
    :慢速路径: addToPendingQueue(signed);
  endif
}

partition "Pending 队列与缺失父块处理" {
  :addToPendingQueue(signed)\n- 将区块按 slot/root 存入 pending 队列结构\n- 记录 parentRoot -> 子块映射\n- 异步触发请求父块 (Req/Resp BlocksByRoot / BlocksByRange);

  :当父块通过 Gossip 或 Req/Resp 抵达时\n- 正常通过 ReceiveBlock 处理父块\n- 调用 processPendingBlocks(parentRoot)\n- 查找所有以 parentRoot 为父的 pending blocks\n- 按 slot 排序后依次再次调用 ReceiveBlock;
}

partition "实时性与早期拒绝 (Early Rejection)" {
  :validateBlockTime(block)\n- blockSlot := block.Block().Slot()\n- currentSlot := chain.CurrentSlot()\n- 若 blockSlot > currentSlot+1 => "block is too far in the future"\n- 若 blockSlot + PropagationRange < currentSlot => "block is too old";

  :validateBeaconBlockPubSub(ctx, msg)\n- 若 hasSeenBlock(msg.ID) => ValidationIgnore\n- quickValidateSlot(msg.Data) 失败 => ValidationReject\n- 否则进入 fullValidateBlock(ctx, msg): 基础检查 / 签名验证 / 状态转换 / 执行 payload 验证 (post-merge);
}

partition "保持同步状态 maintainSync" {
  :maintainSync()\n- 每 12s (1 slot) 触发一次检查;

  :isFallingBehind()\n- currentSlot := chain.CurrentSlot()\n- headSlot := chain.HeadSlot()\n- 若 currentSlot - headSlot > 2 * SlotsPerEpoch 视为 Falling Behind;
  if (isFallingBehind == true) then (落后较多)
    :log.Warn("Falling behind, may need to resync");
    :requestMissingBlocks(): 通过 Req/Resp 向 peers 主动请求缺失区块, 可能触发重新进入 Initial / Catch-up Sync 流程;
  endif
}

stop

@enduml
